---
title: "Impact des mammites sur la décision de mise à la reproduction"
author: "Joanna"
format: html
editor: visual
---

```{r setup}
#| message: false
library(tidyverse)
library(lme4)
library(marginaleffects)
library(readxl)
library(ggplot2)
library(corrplot)
library(questionr)
library(car)
```

```{r seuil utilisés}
## nombre de jours en dessous duquel on considère qu'on est en début de lactation
## en moyenne avant première IA
early_dim_cutoff <- 90
## SCC cut-off
## seuil de cellules au-delà duquel on considère
## qu'il y a mammite clinique
scc_high_cutoff <- 200
```

# Matériel

## Données

Chargement des données de contrôle laitier fournies par IDELE

```{r chargement donnees}
#| message: false
rec <- read_csv2("generated_datasets/idele_rec_final.csv") |> 
  mutate(
    herd_id = as.character(herd_id),
    ctrl_date = as.Date(ctrl_date),
    anim_id = as.character(anim_id),
    parity = as.integer(parity),
    fat = as.integer(fat),
    prot = as.integer(prot),
    scc = as.integer(scc),
    out_cause = as.character(out_cause),
    calv_date = as.Date(calv_date),
    dim = as.integer(dim)
  ) |> 
  filter(!is.na(milk) & !is.na(scc))
```

## Création d'un jeu de données lactations

Dans ce jeu de données on a le contrôle laitier par lactation, qui est l'unité statistique qui nous intéresse. A cela on ajoute les données de la lactation précédente et celles de la lactation suivante. A patir de ces données on définit si la vache est infectée ou non avant tarissement, infectée ou non en début de la lactation suivante et à partir de ça on peut définir si elle s'est infecté au cours du tarissement, si elle a guérit au tarissement ou si elle est restée infectée malgré le tarissement.

```{r}
lac <- rec |> 
  group_by(anim_id, parity) |> 
  summarise(
    herd_id = herd_id[1],
    calv_date = unique(calv_date),
    out_date_last = max(out_date),
    out_cause_last = unique(out_cause[out_date == out_date_last]),
    n_ctrl = length(unique(ctrl_date)),
    n_ctrl_early = length(unique(ctrl_date[dim <= early_dim_cutoff])),
    n_scc_high_early = length(scc[scc > scc_high_cutoff & dim <= early_dim_cutoff]),
    milk_early_max = max(milk[dim <= early_dim_cutoff]),
    dim_first = min(dim),
    scc_first = scc[dim == dim_first],
    dim_last = max(dim),
    milk_last = milk[dim == dim_last],
    scc_last = scc[dim == dim_last]
            ) |> 
  ungroup() |> 
  group_by(anim_id) |> 
  mutate(
    calv_date_prev = lag(calv_date),
    milk_last_prev_lac = lag(milk_last),
    dim_last_prev_lac = lag(dim_last),
    scc_last_prev_lac = lag(scc_last),
    calv_date_nxt = lead(calv_date),
    scc_first_nxt_lac = lead(scc_first),
    infct_end_lac = case_when(
     is.na(scc_last) | is.na(scc_first_nxt_lac) ~ NA,
     !is.na(scc_last) & !is.na(scc_first_nxt_lac) & scc_last < scc_high_cutoff ~ "0",
     !is.na(scc_last) & !is.na(scc_first_nxt_lac) & scc_last >= scc_high_cutoff ~ "1"
      ),
    infct_ctrl1_nxt_lac = case_when(
     is.na(scc_last) | is.na(scc_first_nxt_lac) ~ NA,
     !is.na(scc_last) & !is.na(scc_first_nxt_lac) & scc_first_nxt_lac < scc_high_cutoff ~ "0",
     !is.na(scc_last) & !is.na(scc_first_nxt_lac) & scc_first_nxt_lac >= scc_high_cutoff ~ "1"
      ),
    nxt_cure = case_when(
      infct_end_lac == 0 ~ NA,
      infct_end_lac == 1 & infct_ctrl1_nxt_lac == 1 ~ 0,
      infct_end_lac == 1 & infct_ctrl1_nxt_lac == 0 ~ 1
      ),
    nxt_ninf = case_when(
      infct_end_lac == 1 ~ NA,
      infct_end_lac == 0 & infct_ctrl1_nxt_lac == 0 ~ 0,
      infct_end_lac == 0 & infct_ctrl1_nxt_lac == 1 ~ 1
      )
    ) |> 
  ungroup()
```

## Reformatage des parités

Pour simplifier l'analyse, je décide de séparer les primipares et les mutlipares. J'utilise la parité 3 comme référence car c'est la parité pour laquelle on considère la vache comme rentable.

```{r definition parite}
lac <- lac |> 
  mutate(parKat = relevel(as.factor(ifelse(parity > 3, 4, parity)), ref = "3"))
```


## Données mammites cliniques

On va extraire les dates de mammites cliniques afin de les ajouter aux lactations correspondantes sur le tableau de données "lac"
```{r chargement des donnees}
path_to_file <- "data/mammites.txt"
mamt <- read_csv2(path_to_file) |>
rename(anim_id = ANIM,
cm_date = DAMACL) |>
select(anim_id, cm_date)
```


POur chaque lactation on ajoute les dates de mammites cliniques et on considère que les lactations débutent 30 jours avant vêlage (on prend en considération une phase de préparation au vêlage pouvant modifier la sensibilité individuelle et la réponse des animaux)

```{r}
lac_cm <- left_join(
lac |>
select(anim_id, calv_date, calv_date_nxt) |>
mutate(
dim_minus30 = calv_date - 30,
dim_early = calv_date + early_dim_cutoff),
mamt) |>
filter(!is.na(cm_date)) |>
group_by(anim_id, calv_date) |>
summarise(
cm_first = min(cm_date[cm_date >= calv_date & (cm_date < calv_date_nxt | is.na(calv_date_nxt))]),
cm_last = max(cm_date[cm_date >= calv_date & (cm_date < calv_date_nxt | is.na(calv_date_nxt))]),
n_cm_early = length(unique(cm_date[cm_date >= dim_minus30 & cm_date < dim_early])),
n_cm_late = length(unique(cm_date[cm_date >= dim_early & (cm_date < calv_date_nxt | is.na(calv_date_nxt))]))
) |>
ungroup()
```

cm_fisrt et cm_last prennent des valeurs égales à -inf et inf --> je ne sais pas encore pourquoi 

le code suivant devrait résoudre ce problème

```{r}
lac_cm$cm_first[is.infinite(lac_cm$cm_first)] <- NA
lac_cm$cm_last[is.infinite(lac_cm$cm_last)] <- NA
```

fusion avec le jeu de données initial 

```{r fusion}
lac <- left_join(lac, lac_cm) |> 
  mutate(
    n_cm_early = ifelse(is.na(n_cm_early), 0, n_cm_early),
    n_cm_late = ifelse(is.na(n_cm_late), 0, n_cm_late)
    )

rm(lac_cm) ## supprime lac_cm de l'espace de travail
```

## Données d"insémination artificielle 

```{r donnees ai}
#| message: false
path_to_file <- "data/extra_femia_20240415.csv"
ai <- read_csv(path_to_file) |> 
  select(anim, DAINAR) |> 
  rename(anim_id = anim,
         ai_date = DAINAR) |> 
  mutate(ai_date = as.Date(ai_date, "%d/%m/%Y"))
```
### Fusion des données d'insémination artificielle avec données lactation

Les données lactations et inséminations artificielles sont fusionnées. On s'assure que chaque date d'IA survient entre un vêlage et le suivant ou entre un vêlage et une absence de vêlage suivant.

```{r lac-ai-join}
nlac <- left_join(lac |> 
                    select(anim_id, calv_date, calv_date_nxt), 
                  ai) |> 
  filter(ai_date > calv_date & (ai_date < calv_date_nxt | is.na(calv_date_nxt))) |>
  group_by(anim_id, calv_date) |> 
  summarise(n_ai = length(unique(ai_date)),
            ai_first = min(ai_date),
            ai_last = max(ai_date)) |> 
  ungroup()

lac <- left_join(lac, nlac) |> 
  mutate(ai1_dim = as.integer(ai_first - calv_date),
         ai_last_dim = as.integer(ai_last - calv_date))
```
## Agrégation des données par élevage et par an 

Les données contrôle laitier et inséminations artificielles sont agrégées à l'échelle élevage-année. L'objectif est de sélectionner les élevages dans lesquels une proportion suffisante des vaches sont inséminées.

```{r agregation elevage-annee}
rec_hdyr <- rec |> 
  mutate(year = as.integer(format(ctrl_date, "%Y"))) |> 
  group_by(herd_id, year) |> 
  summarise(n_ctrl = length(unique(ctrl_date)),
            n_cows_rec = length(unique(anim_id)),
            p_primi_rec = round(length(parity[parity == 1]) / length(parity), 3)) |> 
  ungroup()
```


Les premières IA de chaque élevage sont comptées

```{r}
ai_hdyr <- lac |> 
  filter(!is.na(n_ai)) |> 
  mutate(year = as.integer(format(ai_first, "%Y"))) |> 
  group_by(herd_id, year) |> 
  summarise(n_cows_ai = length(n_ai[!is.na(n_ai)])) |> 
  ungroup()
```

Fusion des 2 jeux de données. Seuls les élevages qui ont à la fois des données contrôle laitier et des données d'IA sont conservés.

```{r rec-ai-herdyear-merge}
hdyr <- inner_join(rec_hdyr, ai_hdyr) |> 
  mutate(p_ai = round(n_cows_ai / n_cows_rec, 3))
```
Remarque Joanna : Pourquoi parfois n_cow_ai > n_cow_rec ? ce qui donne p_ai > 1...


## Ajout des données de production laitière en début de lactation 

On va commencer par ajouter la production laitière en début de lactation et la standardiser pour en faire une variable comparable. 
De plus il faut différencier la PL des primipares avec la PL des multipares car elles ne sont pas vraiment comparables, en réalité une multipare produit généralement plus qu'une primipare. 

```{r normalisation du max de production laitière}
milk_early_max_mean <- with(lac[lac$n_ctrl_early > 0,], 
                            mean(milk_early_max))

milk_early_max_sd   <- with(lac[lac$n_ctrl_early > 0,], 
                            sd(milk_early_max))

lac <- lac |> 
  filter(n_ctrl_early > 0) |> 
  mutate(parKat = relevel(as.factor(ifelse(parity > 3, 4, parity)), ref = "3"),
         milk_early_max_scaled = (milk_early_max - milk_early_max_mean) / 
           milk_early_max_sd,
  milk_early_max_scaled_p1 = ifelse(parity == 1, milk_early_max_scaled, 0),
  milk_early_max_scaled_p2 = ifelse(parity == 2, milk_early_max_scaled, 0),
  milk_early_max_scaled_p3 = ifelse(parity == 3, milk_early_max_scaled, 0),
  milk_early_max_scaled_p4 = ifelse(parity > 3, milk_early_max_scaled, 0),
  milk_early_max_scaled_p1plus = ifelse(parity > 1, milk_early_max_scaled, 0))

```

```{r}
hist(lac$milk_early_max_scaled,
     main = "Distribution du maximum de production laitière\npendant les 90 premiers jours de lactation",
     xlab = "Production laitière (distribution centrée réduite)")
```


## Définition des mammites

Afin de modéliser l'impact des mammites sur la décision de reproduction, il est important de définir les différents types de mammites. On en définit ici : - mammite à réservoir environnementale : typiquement c'est un épisode de mammite isolé qui guérit rapidement et qui ne suit pas un modèle contagieux mais plutôt un modèle sporadique - mammite à réservoir mammaire : mammite qui tend à passer à la chronicité et entraîner une forte contagions au sein de l'élevage.

On va également différencier les différentes périodes de survenue des mammites en se concentrant tout d'abord sur la période de début de lactation : 
- Les primipares débutent leur toute première lactation, elle n'ont pas encore connu de période sèche et n'ont pas encore eu l'occasion de se contaminer
- Les multipares ont déjà pu se contaminer lors de la lactation précédente, on va donc prendre en compte son statut lors de la période sèche. 

Le statut "primi" sera donc considéré comme référence. 

### Statut au tarissement

```{r}
lac <- lac |> 
  mutate(dp_status = case_when(
    parity == 1 ~ "primi",
    scc_last_prev_lac < scc_high_cutoff ~ "dpLow", 
    scc_last_prev_lac >= scc_high_cutoff ~ "dpHigh"),
    dp_status = relevel(factor(dp_status), ref = "primi"))
```

```{r}
lac <- lac |> 
filter(!is.na(dp_status)) 
```


### Type de mammite

```{r}
lac <- lac |> 
  mutate( mast_cat = case_when(
    n_scc_high_early == 0 & n_cm_early == 0 ~ "healthy",
    n_scc_high_early == 1 | (n_scc_high_early == 0 & n_cm_early > 0) ~ "env",
    n_scc_high_early > 1 ~ "cont"),
    mast_cat = relevel(factor( mast_cat), ref = "healthy"),
    mast_cat1 = relevel(factor(paste(dp_status, mast_cat, sep = "_")), ref = "primi_healthy"),
    mast_cat2 = relevel(factor(paste(ifelse(dp_status == "primi", "primi", "multi"), mast_cat, sep = "_")), ref = "primi_healthy")
  )
```

Certaines multipares n'ont pas de données pour la lactation précédente. Elles sont identifiées et exclues de l'analyse.

```{r}
lac <- lac |> 
  mutate(dp_mis = ifelse(parity > 1 & is.na(scc_last_prev_lac), 1, 0))
```



```{r formatage des categories de mammites pour les predictions}
## catégories de statuts mammites pour les primipares
mast_lev_p1 <- lac |> 
  filter(n_ctrl_early > 0 & dp_mis == 0 & parKat == 1) |> 
  distinct(mast_cat1) |>
  mutate(mast_cat1 = as.character(mast_cat1)) |>
  pull(mast_cat1)
## catégories de statuts mammites pour les multipares
mast_lev_p2 <- lac |> 
  filter(n_ctrl_early > 0 & dp_mis == 0 & parKat != 1) |> 
  distinct(mast_cat1) |>
  mutate(mast_cat1 = as.character(mast_cat1)) |>
  pull(mast_cat1)

## jeu de données
mast_pred <- tibble(
  parKat = factor(c(rep(1, length(mast_lev_p1)),
             rep(2, length(mast_lev_p2)))),
  mast_cat1 = factor(c(mast_lev_p1, mast_lev_p2)),
  milk_early_max_scaled_p1 = 0,
  milk_early_max_scaled_p2 = 0,
  milk_early_max_scaled_p3 = 0,
  milk_early_max_scaled_p4 = 0,
  n_ai = 0
)

level_order <- c("primi_healthy",  "primi_env", "primi_cont",
                 "dpLow_healthy",  "dpLow_env", "dpLow_cont",
                 "dpHigh_healthy", "dpHigh_env", "dpHigh_cont") 
  
```

## Décision de mise à la reproduction

```{r}
lac <- lac |> 
  mutate(
    repro = ifelse(!is.na(n_ai) | !is.na(calv_date_nxt), 1, 0))
```

```{r saving lac data}
save(lac, file = "~/stage_these/longevity_health/generated_datasets/lac.RData")
```


# Méthode

## Déscription de la mise à la reproduction selon la présence ou non d'une mammite 

```{r}
# Tableau d'effectif
Tab<-table(lac$repro, lac$mast_cat1)
Tab
```

```{r}
p<-ggplot(lac) +
aes(x = repro, fill = mast_cat1) +
geom_bar(position="fill") +
xlab("mise à la reproduction") +
ylab("Effectifs") +
labs(fill = "catégories")
p+theme_bw()
## x = Nbre de groupe sur l'axe x
## fill = Nbre de barres par groupe
## position="fill" = rend le graphique proportionnel et empile les barres
```

On va essayer de visualiser les différentes relations entre variables explicatives grâce à une matrice de corrélation. 

```{r matrice de correlation}
lac$parKat <- as.numeric(as.factor(lac$parKat))
lac$mast_cat1 <- as.numeric(as.factor(lac$mast_cat1))


# Sélectionner les colonnes d'intérêt
variables_of_interest <- lac[, c("parKat", "milk_early_max_scaled_p1", "milk_early_max_scaled_p2", "milk_early_max_scaled_p3", "milk_early_max_scaled_p4", "mast_cat1")]

# Calculer la matrice de corrélation
cor_matrix <- cor(variables_of_interest, use = "complete.obs")
print(cor_matrix)
```

```{r sous forme de graphique}
corrplot(cor_matrix, method = "circle")
```

## Modélisation de l'impact des mammites sur la probabilité de mise à la reproduction 

### Modèle de référence 

Ce modèle ne prend que des données parmis des animaux dont on a des informations sur le début de lactation et la période sèche de la précédente lactation. 

```{r modèle de référence}
repro_null <- glmer(repro ~ 1 + (1 | herd_id),
                    data = lac,
                    subset = n_ctrl_early > 0 & dp_mis == 0,
                    family = binomial(link = "logit"))

summary(repro_null)
```
On peut grâce à ce modèle obtenir la probabilité de mise à la reproduction mais pour cela il faut d'abords calculer 

```{r methode de prediction des probabilites}
# Obtenir les prédictions sur l'échelle de probabilité
predicted_probabilities <- predict(repro_null, type = "response")

# Afficher les premières prédictions pour vérification
head(predicted_probabilities)
```

```{r methode aurelien}
# Définir la fonction invlogit 
invlogit <- function(x) {
  exp(x) / (1 + exp(x))
}

# Extraire les coefficients fixes et calculer la probabilité
prob_repro <- as.double(round(invlogit(fixef(repro_null)), 3))

# Afficher la probabilité
prob_repro
```
### Modèle avec parité et production laitière 

```{r}
repro_parity <- glmer(repro ~ parKat + (1 | herd_id),
                    data = lac,
                    subset = n_ctrl_early > 0 & dp_mis == 0,
                    family = binomial(link = "logit"))

summary(repro_parity)
```

```{r}
repro_parity_milk <- glmer(repro ~ parKat + 
                              milk_early_max_scaled_p1 + 
                              milk_early_max_scaled_p2 + 
                              milk_early_max_scaled_p3 + 
                              milk_early_max_scaled_p4 + 
                      (1 | herd_id),
                    data = lac,
                    subset = n_ctrl_early > 0 & dp_mis == 0,
                    family = binomial(link = "logit"))

summary(repro_parity_milk)
```

Ce modèle semble correct, les résidus varient de -19.7623 à 2.4783, avec une médiane de 0.3450, ce qui suggère quelques observations extrêmes (potentiellement influentes).

On va maintenant ajouter la variable d'intêret qui est la présence ou non de mammite 

### Modèle complet 

```{r}
repro_full <- glmer(repro ~ parKat + 
                              milk_early_max_scaled_p1 + 
                              milk_early_max_scaled_p2 + 
                              milk_early_max_scaled_p3 + 
                              milk_early_max_scaled_p4 + 
                             dp_status + mast_cat +
                      (1 | herd_id),
                    data = lac,
                    subset = n_ctrl_early > 0 & dp_mis == 0,
                    family = binomial(link = "logit"))

summary(repro_full)
```

```{r}
repro_full1 <- glmer(repro ~ parKat + 
                              milk_early_max_scaled_p1 + 
                              milk_early_max_scaled_p2 + 
                              milk_early_max_scaled_p3 + 
                              milk_early_max_scaled_p4 + 
                              mast_cat1 +
                      (1 | herd_id),
                    data = lac,
                    subset = n_ctrl_early > 0 & dp_mis == 0,
                    family = binomial(link = "logit"))

summary(repro_full1)
``` 

POur améliorer ce modèle nous allons essayer quelques modifications : La première va être de mettres certaines variables au carré.

```{r ajout de terme quadratiques}
lac <- lac |> 
  mutate(milk_early_max_scaled_p1_sq = lac$milk_early_max_scaled_p1^2,
         milk_early_max_scaled_p2_sq = lac$milk_early_max_scaled_p2^2,
        milk_early_max_scaled_p3_sq = lac$milk_early_max_scaled_p3^2,
        milk_early_max_scaled_p4_sq = lac$milk_early_max_scaled_p4^2)
```

On va refaire un modèle avec des termes quadratiles pour voir si cela améliore la qualité du modèle. 

```{r}
repro_full2 <- glmer(repro ~ parKat + 
                              milk_early_max_scaled_p1_sq + 
                              milk_early_max_scaled_p1 +
                              milk_early_max_scaled_p2_sq +
                              milk_early_max_scaled_p2 +
                              milk_early_max_scaled_p3_sq + 
                              milk_early_max_scaled_p3 +
                              milk_early_max_scaled_p4_sq +
                              milk_early_max_scaled_p4 +
                              mast_cat1 +
                      (1 | herd_id),
                    data = lac,
                    subset = n_ctrl_early > 0 & dp_mis == 0,
                    family = binomial(link = "logit"))

summary(repro_full2)
```

Il semblerait que repro_full1 convienne mieux que repro_full2 car son AIC est plus petit. 

Nous allons essayer d'ajouter des interactions pour voir si cela améliore le modèle. 

```{r, eval = FALSE}
lac_fltr <- lac |> 
  filter(is.na(n_ai) & !is.na(calv_date_nxt))

lac_soustrait <- anti_join(lac, lac_fltr)
```

on effectue une nouvelle régression logistique 

```{r, evaL = FALSE}
repro_full3 <- glmer(repro ~ parKat + 
                              milk_early_max_scaled_p1_sq + 
                              milk_early_max_scaled_p2_sq + 
                              milk_early_max_scaled_p3_sq + 
                              milk_early_max_scaled_p4_sq + 
                              mast_cat1 +
                      (1 | herd_id),
                    data = lac_soustrait,
                    subset = n_ctrl_early > 0 & dp_mis == 0,
                    family = binomial(link = "logit"))

summary(repro_full3)
```

Maintenant on ajoute quelques intéractions pour essayer d'améliorer le modèle. 

```{r}
repro_full4 <- glmer(repro ~ parKat + 
                              milk_early_max_scaled_p1 + 
                              milk_early_max_scaled_p2 + 
                              milk_early_max_scaled_p3 + 
                              milk_early_max_scaled_p4 + 
                              mast_cat1 +
                              milk_early_max_scaled_p1*mast_cat1 +
                              milk_early_max_scaled_p2*mast_cat1 +
                              milk_early_max_scaled_p3*mast_cat1 +
                              milk_early_max_scaled_p4*mast_cat1 +
                              (1 | herd_id),
                              data = lac,
                              subset = n_ctrl_early > 0 & dp_mis == 0,
                              family = binomial(link = "logit"))

summary(repro_full4)
```

Pour l'instant c'est repro_full1 qui donne la meilleure approximation car il possède le plus petit AIC. 

On va donc maintenant vérifier sa pertinence. 

### Vérification du modèle 

#### vérification de l'absence de multicolinéarité des variables explicatives

```{r}
vif(repro_full1)
```
tous les VIF sont inférieurs à 5 donc les variables sont suffisemment indépendantes. 

#### Vérification de l'homoscédasticité des résidus 

Ce n'est pas forcément pertinent de tester l'homoscédasticité des résidus en régression logistique mais cela peut permettre d'ajuster le modèle si besoin. 

```{r}
# Calculer les résidus de Pearson
residuals_pearson <- residuals(repro_full1, type = "pearson")

# Tracer les résidus de Pearson
plot(fitted(repro_full1), residuals_pearson, 
     xlab = "Valeurs ajustées", 
     ylab = "Résidus de Pearson",
     main = "Résidus de Pearson vs Valeurs ajustées")
abline(h = 0, col = "red")
plot(repro_full1$fit$fitted.values, repro_full1$resid)
```
## Probabilité de mise à la reproduction selon le statut de l'animal 


```{r}
prd <- marginaleffects::predictions(model = repro_full1, 
                             newdata = mast_pred, 
                           re.form = NA, type = "response")

ggplot(prd, aes(x = factor(mast_cat1, level = level_order), y = estimate)) +
  geom_point() +
  geom_segment(aes(x = mast_cat1, y = conf.low, xend = mast_cat1, yend = conf.high)) +
  xlab("") + 
  ylab("Probabilité de mise à la reproduction") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

La figure ci-dessous représente les probabilités prédites qu'une vache soit mise à la reproduction en fonction de son statut vis-à-vis des mammites.
Les multipares représentent la parité de référence qui est la parité 3. 

## Probabilité de revêlage pour les vaches mises à la reproduction

Une variable binaire prenant la valeur 1 si la vache revêle et 0 autrement est construite.


```{r recalving-var-definition}
lac <- lac |> 
  mutate(
    repro_revel = case_when(
      repro == 1 & !is.na(calv_date_nxt) ~ 1,
      repro == 1 & is.na(calv_date_nxt) ~ 0,
      repro == 0 ~ NA
    )
    )
```

Le modèle suivant estime la probabilité qu'une vache mise à la reproduction revêle.

```{r recalving-var-null-model}
repro_revel_null <- glmer(repro_revel ~ 1 + (1 |herd_id),
                          family = binomial(link = "logit"),
                          data = lac,
                    subset = n_ctrl_early > 0 & repro == 1 & dp_mis == 0)

summary(repro_revel_null)
```
```{r}
# Définir la fonction invlogit 
invlogit <- function(x) {
  exp(x) / (1 + exp(x))
}

# Extraire les coefficients fixes et calculer la probabilité
prob_revel <- as.double(round(invlogit(fixef(repro_revel_null)), 3))

# Afficher la probabilité
prob_revel
```
On va maintenant compliquer graduellement le modèle en essayant de trouver le modèle le plus juste possible. On va commencer par utiliser exactement les mêmes variables que pour le modèle de mise à la reproduction.

```{r}
repro_revel_mast <- glmer(repro_revel ~  parKat + 
                              milk_early_max_scaled_p1 + 
                              milk_early_max_scaled_p2 + 
                              milk_early_max_scaled_p3 + 
                              milk_early_max_scaled_p4 + 
                              mast_cat1 + 
                           (1 |herd_id),
                          family = binomial(link = "logit"),
                          data = lac,
                         subset = n_ctrl_early > 0 & repro == 1 & dp_mis == 0)

summary(repro_revel_mast)
```
```{r}
repro_revel_mast1 <- glmer(repro_revel ~  parKat + 
                              milk_early_max_scaled_p1 + 
                              milk_early_max_scaled_p2 + 
                              milk_early_max_scaled_p3 + 
                              milk_early_max_scaled_p4 + 
                              mast_cat1 +
                              n_ai +
                           (1 |herd_id),
                          family = binomial(link = "logit"),
                          data = lac,
                         subset = n_ctrl_early > 0 & repro == 1 & dp_mis == 0)

summary(repro_revel_mast1)
```

Ce modèle semble meilleur cependant il est évident que plus le nombre d'inséminations artificielles augmentent plus la probabilité de revêler augmente. 

```{r}
repro_revel_mast2 <- glmer(repro_revel ~  parKat + 
                              milk_early_max_scaled_p1 + 
                              milk_early_max_scaled_p2 + 
                              milk_early_max_scaled_p3 + 
                              milk_early_max_scaled_p4 + 
                              mast_cat1 +
                              n_ai +
                              n_ai*mast_cat1 +
                           (1 |herd_id),
                          family = binomial(link = "logit"),
                          data = lac,
                         subset = n_ctrl_early > 0 & repro == 1 & dp_mis == 0)

summary(repro_revel_mast2)
```

```{r}
repro_revel_mast3 <- glmer(repro_revel ~  parKat + 
                              milk_early_max_scaled_p1 + 
                              milk_early_max_scaled_p2 + 
                              milk_early_max_scaled_p3 + 
                              milk_early_max_scaled_p4 + 
                              mast_cat1 +
                              n_ai +
                              n_ai*parKat +
                           (1 |herd_id),
                          family = binomial(link = "logit"),
                          data = lac,
                         subset = n_ctrl_early > 0 & repro == 1 & dp_mis == 0)

summary(repro_revel_mast3)
```
Ce modèle semble un peu mieux, pour l'instant c'est celui qui nous convient le mieux. 

### Vérification du modèle 

#### vérification de l'absence de multicolinéarité des variables explicatives

```{r}
vif(repro_revel_mast3)
```
n_ai et parKat*n_ai semblent indiquer une colinéarité modérée

## Probabilité de revêlage suite à la mise à la reproduction 

```{r}
prd <- marginaleffects::predictions(model = repro_revel_mast3, 
                             newdata = mast_pred, 
                            re.form = NA, type = "response")

ggplot(prd, aes(x = factor(mast_cat1, level = level_order), y = estimate)) +
  geom_point() +
  geom_segment(aes(x = mast_cat1, y = conf.low, xend = mast_cat1, yend = conf.high)) +
  xlab("") + 
  ylab("Probabilité de revêlage") +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))
```

